[{"Title":"Right-Click Context Menus In GtkSharp","Lead":null,"Published":"2010-04-12T00:00:00","Edited":"0001-01-01T00:00:00","Tags":["Mono","GtkSharp","ButtonPressEvent","Context Menu","ContextMenuHelper","Menu","Popup","Popup Menu"],"ViewTypeName":"right_click_context_menus_in_gtksharp","Rendered":"\r\n\r\n<p>To show a context menu in GtkSharp (or \"popup\" as they're called in Gtk land), you would normally add an event handler for Widget.PopupMenu, create or use a Menu instance, and then call Menu.Popup. The only problem is that for many widgets, the right-click doesn't trigger the Widget.PopupMenu event. This is fine for systems where there is no right mouse button or where a right-click isn't the customary way of initiating context menus. However, on systems where there is a user expectation that the way to open a context menu is through a right-click (such as Windows), we need some way to trigger one.</p>\r\n<p>The situation is complicated a little bit by the existing behavior of Widget.PopupMenu. According to the <a href=\"http://library.gnome.org/devel/gtk/unstable/gtk-migrating-checklist.html#checklist-popup-menu\">Gtk manual</a>, \"By default, the key binding mechanism is set to emit this signal when the Shift+F10 or Menu keys are pressed while a widget has the focus.\" There is a recommendation in the manual that if a developer wants context menus on right-click they should handle the Widget.ButtonPressEvent, listen for the appropriate clicks, and launch the menu using the Menu.Popup method. This is all fine except that now you've got two things to listen to to get proper context menu handling: Widget.PopupMenu and Widget.ButtonPressEvent. It would be nice if there were just one event to handle that got raised anytime a context menu needed to be displayed.</p>\r\n<p>The following class does just that. You can \"attach\" it to any Widget and it will listen for the Widget.PopupMenu event to work with the default context menu handling and the Widget.ButtonPressEvent to also work with right-clicks. When either of these occur, it will first propagate the event through to the underlying Widget (in case there are other things that are supposed to be triggered by whatever event caused the context menu) and then raise a ContextMenuHelper.ContextMenu event that you can handle and use to display the context menu regardless of what triggered it. This method should ensure proper event handling and ordering while reducing duplication of code by enabling a single event for context menu handling.</p>\r\n\r\n<pre><code class=\"language-csharp\">using System;\r\nusing Gdk;\r\nusing GLib;\r\nusing Gtk;\r\n\r\nnamespace Somedave\r\n{\r\n public class ContextMenuEventArgs : EventArgs\r\n {\r\n  private Widget widget;\r\n  public Widget Widget { get { return widget; } }\r\n\r\n  private bool rightClick;\r\n  public bool RightClick { get { return rightClick; } }\r\n\r\n  public ContextMenuEventArgs(Widget widget, bool rightClick)\r\n  {\r\n   this.widget = widget;\r\n   this.rightClick = rightClick;\r\n  }\r\n }\r\n\r\n public class ContextMenuHelper\r\n {\r\n  public event EventHandler&lt;ContextMenuEventArgs&gt; ContextMenu;\r\n\r\n  public ContextMenuHelper()\r\n  {}\r\n\r\n  public ContextMenuHelper(Widget widget)\r\n  {\r\n   AttachToWidget(widget);\r\n  }\r\n\r\n  public ContextMenuHelper(Widget widget, EventHandler handler)\r\n  {\r\n   AttachToWidget(widget);\r\n   ContextMenu += handler;\r\n  }\r\n\r\n  public void AttachToWidget(Widget widget)\r\n  {\r\n   widget.PopupMenu += Widget_PopupMenu;\r\n   widget.ButtonPressEvent += Widget_ButtonPressEvent;\r\n  }\r\n\r\n  public void DetachFromWidget(Widget widget)\r\n  {\r\n   widget.PopupMenu -= Widget_PopupMenu;\r\n   widget.ButtonPressEvent -= Widget_ButtonPressEvent;\r\n  }\r\n\r\n  [GLib.ConnectBefore]\r\n  private void Widget_PopupMenu(object o, PopupMenuArgs args)\r\n  {\r\n   RaiseContextMenuEvent(args, (Widget)o, false);\r\n  }\r\n\r\n  [GLib.ConnectBefore]\r\n  private void Widget_ButtonPressEvent(object o, ButtonPressEventArgs args)\r\n  {\r\n   if (args.Event.Button == 3 &amp;&amp; args.Event.Type == EventType.ButtonPress)\r\n   {\r\n    RaiseContextMenuEvent(args, (Widget)o, true);\r\n   }\r\n  }\r\n\r\n  private bool propagating = false;   //Prevent reentry\r\n\r\n  private void RaiseContextMenuEvent(SignalArgs signalArgs, Widget widget, bool rightClick)\r\n  {\r\n   if (!propagating)\r\n   {\r\n    //Propagate the event\r\n    Event evnt = Gtk.Global.CurrentEvent;\r\n    propagating = true;\r\n    Gtk.Global.PropagateEvent(widget, evnt);\r\n    propagating = false;\r\n    signalArgs.RetVal = true;     //The widget already processed the event in the propagation\r\n\r\n    //Raise the context menu event\r\n    ContextMenuEventArgs args = new ContextMenuEventArgs(widget, rightClick);\r\n    if (ContextMenu != null)\r\n    {\r\n     ContextMenu.Invoke(this, args);\r\n    }\r\n   }\r\n  }\r\n }\r\n}\r\n</code></pre>"},{"Title":"Exporting a GtkSharp TreeView to CSV","Lead":"All packaged up in nice little utility methods.","Published":"2010-04-09T00:00:00","Edited":"0001-01-01T00:00:00","Tags":["Mono","GtkSharp","CellRenderer","CSV","TreeModel","TreeView","TreeViewColumn"],"ViewTypeName":"exporting_a_gtksharp_treeview_to_csv","Rendered":"\r\n\r\n<p>I recently had to create some functionality to export a TreeView widget to a CSV file for further analysis. Since I tend to think about generic behavior, I decided to code up a method that would take any arbitrary TreeView and perform the export operation. Luckily, the TreeView widget and the attached TreeModel both contain a lot of functionality for accessing the data and it's presentation. I decided that I wanted the exported CSV file to represent the perspective of the model as currently represented in the TreeView including column visibility and sort order. This led to the trickiest part of the process. Because a CellRenderer can be customized using cell data functions (such as those added by a call to TreeViewColumn.SetCellDataFunc), I had to pull the content to export from the CellRenderer as opposed to pulling directly from the TreeModel. Turns out there's a method to take the TreeIter from a TreeModel and apply it to all the CellRenderers in a given TreeViewColumn. Since I really only care about textual content, I decided to only export those columns that contain CellRendererText renderers.</p>\r\n<p>After working out the algorithm to fetch what needed to be exported I thought I was ready to roll. Turns out that the CSV pseudo-standard is pretty complex though (the RFC is <a href=\"http://www.rfc-editor.org/rfc/rfc4180.txt\">here</a>), and I quickly got bogged down in writing all kinds of special cases for escaping, quoting, etc. Thankfully, someone else had already been down this road and I was able to find the excellent <a href=\"http://kbcsv.codeplex.com/\">KBCsv</a> library which will write and read formatted CSV files. My only complaint was that it used another utility library purely for convenience in exception generation and null checking (I already use a ton of libraries in our application and I'd prefer not to add any unnecessarily). I replaced the calls to the utility library with the language equivalents, but that's totally a personal preference.</p>\r\n<p>Without further adieu, I present the <code>TreeViewHelper.ExportToCsv</code> and <code>TreeViewHelper.ExportToCsvFile</code> methods...</p>\r\n<pre><code class=\"language-csharp\">using System;\r\nusing System.Collections.Generic;\r\nusing System.IO;\r\nusing Gtk;\r\nusing Kent.Boogaart.KBCsv;\r\n\r\nnamespace Somedave\r\n{\r\n public static class TreeViewHelper\r\n {\r\n  public static bool ExportToCsv(TreeView treeView, Window parent)\r\n  {\r\n   FileChooserDialog fcd = new FileChooserDialog(\"Export File\", parent, FileChooserAction.Save,\r\n   \"Cancel\", ResponseType.Cancel, \"Export\", ResponseType.Accept);\r\n   fcd.DoOverwriteConfirmation = true;\r\n   FileFilter filter = new FileFilter { Name = \"CSV File\" };\r\n   filter.AddPattern(\"*.csv\");\r\n   fcd.AddFilter(filter);\r\n   if (fcd.Run() == (int)ResponseType.Accept)\r\n   {\r\n    string path = fcd.Filename;\r\n    fcd.Destroy();\r\n    return ExportToCsvFile(treeView, path);\r\n   }\r\n   fcd.Destroy();\r\n   return false;\r\n  }\r\n\r\n  public static bool ExportToCsvFile(TreeView treeView, string path)\r\n  {\r\n   //Get the iterator\r\n   TreeIter iter;\r\n   if (treeView.Model.GetIterFirst(out iter))\r\n   {\r\n    //Create the stream\r\n    using (StreamWriter streamWriter = new StreamWriter(path, false))\r\n    {\r\n     //Create the CSV writer\r\n     using (CsvWriter csvWriter = new CsvWriter(streamWriter))\r\n     {\r\n      List&lt;string&gt; headers = new List&lt;string&gt;();\r\n      List&lt;string&gt; values = new List&lt;string&gt;();\r\n\r\n      //Traverse the tree\r\n      do\r\n      {\r\n       values.Clear();\r\n       foreach (TreeViewColumn column in treeView.Columns)\r\n       {\r\n        //Only output visible columns\r\n        if (column.Visible)\r\n        {\r\n         //Loop through CellRenderers to make sure we have a CellRendererText\r\n         string value = null;\r\n         column.CellSetCellData(treeView.Model, iter, false, false);\r\n         foreach (CellRenderer renderer in column.CellRenderers)\r\n         {\r\n          CellRendererText text = renderer as CellRendererText;\r\n          if (text != null)\r\n          {\r\n           //Setting value indicates this column had a CellRendererText and should be included\r\n           if (value == null)\r\n           {\r\n            value = String.Empty;\r\n           }\r\n\r\n           //Add the header if the first time through\r\n           if (headers != null)\r\n           {\r\n            headers.Add(column.Title);\r\n           }\r\n\r\n           //Append to the value\r\n           if (text.Text != null)\r\n           {\r\n            value += text.Text;\r\n           }\r\n          }\r\n         }\r\n         if (value != null)\r\n         {\r\n          values.Add(value);\r\n         }\r\n        }\r\n       }\r\n\r\n       //Output the header\r\n       if (headers != null)\r\n       {\r\n        csvWriter.WriteHeaderRecord(headers.ToArray());\r\n        headers = null;\r\n       }\r\n\r\n       //Output the values\r\n       csvWriter.WriteDataRecord(values.ToArray());\r\n      } while (treeView.Model.IterNext(ref iter));\r\n     }\r\n    }\r\n    return true;\r\n   }\r\n   return false;\r\n  }\r\n }\r\n}\r\n</code></pre>\r\n\r\n"}]