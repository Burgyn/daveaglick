#pragma warning disable 1591
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Somedave.Views.Blog.Posts
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Text;
    using System.Web;
    using System.Web.Helpers;
    using System.Web.Mvc;
    using System.Web.Mvc.Ajax;
    using System.Web.Mvc.Html;
    using System.Web.Routing;
    using System.Web.Security;
    using System.Web.UI;
    using System.Web.WebPages;
    using FluentBootstrap;
    using Somedave;
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
    [System.Web.WebPages.PageVirtualPathAttribute("~/Views/Blog/Posts/custom-entity-type-configurations-in-entity-framework-code-fir" +
        "st-part-1.cshtml")]
    public partial class custom_entity_type_configurations_in_entity_framework_code_first_part_1 : Somedave.BlogPostViewPage<dynamic>
    {
        public custom_entity_type_configurations_in_entity_framework_code_first_part_1()
        {
        }
        public override void Execute()
        {
            
            #line 1 "..\..\Views\Blog\Posts\custom-entity-type-configurations-in-entity-framework-code-first-part-1.cshtml"
  
    Title = "Custom Entity Type Configurations in Entity Framework Code First (Part 1)";
    Published = new DateTime(2013, 4, 17);
    Tags = new[] { "Entity Framework", "Entity Framework Code First" };

            
            #line default
            #line hidden
WriteLiteral("\r\n\r\n<p>One of the things I really like about Entity Framework Code First is the w" +
"ay you can mix declarative configuration (I.e., by using <a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/dd901590(v=vs.95).aspx\"");

WriteLiteral(">Data Annotation</a> attributes) with programmatic configuration for more complic" +
"ated cases (I.e., by using the <a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-US/data/jj591617\"");

WriteLiteral(">fluent API</a>). The one aspect of this that really bothers me though is that in" +
" normal usage the fluent API commands end up being placed inside your <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.data.entity.dbcontext(v=vs." +
"103).aspx\"");

WriteLiteral(">DbContext</a></code> class removed from your actual entity. If you change some a" +
"spect of an entity that uses the fluent API for configuration, you have to remem" +
"ber to go check the <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.data.entity.dbcontext.onmod" +
"elcreating(v=vs.103).aspx\"");

WriteLiteral(@">OnModelCreating()</a></code> method to ensure you don't need to modify the code-based configuration. It would be much better (in my opinion) if all configuration, declarative and programmatic, were located close to the entity and/or encapsulated within it. This article explains one way of accomplishing this.</p>

<p>The first thing you'll need to understand is the way that the fluent API actually configures entities. Inside of the <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.data.entity.dbcontext(v=vs." +
"103).aspx\"");

WriteLiteral(">DbContext</a></code> class (which you\'ve presumably subclassed) there is an over" +
"ridable method called <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.data.entity.dbcontext.onmod" +
"elcreating(v=vs.103).aspx\"");

WriteLiteral(">OnModelCreating()</a></code>. This method has a single parameter of type <code><" +
"a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.data.entity.dbmodelbuilder(" +
"v=vs.103).aspx\"");

WriteLiteral(">DbModelBuilder</a></code>. During normal fluent API usage you write code that lo" +
"oks like this inside the <code>OnModelCreating()</code> method:</p>\r\n\r\n<pre><cod" +
"e");

WriteLiteral(" class=\"language-csharp\"");

WriteLiteral(">modelBuilder.Entity&lt;Department&gt;().Property(t =&gt; t.Name).IsRequired();</" +
"code></pre>\r\n\r\n<p>When you call <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/gg696542(v=vs.103).aspx\"");

WriteLiteral(">DbModelBuilder.Entity&lt;TEntityType&gt;()</a></code>, you get back an <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/gg696117(v=vs.103).aspx\"");

WriteLiteral(">EntityTypeConfiguration&lt;TEntityType&gt;</a></code> class that is used for con" +
"figuring the entity. However, this isn\'t the only way to get an <code>EntityType" +
"Configuration</code> class. You can actually create them yourself:</p>\r\n\r\n<pre><" +
"code");

WriteLiteral(" class=\"language-csharp\"");

WriteLiteral(@">public class DepartmentTypeConfiguration : EntityTypeConfiguration&lt;Department&gt;
{
  public DepartmentTypeConfiguration() { }
}</code></pre>

<p>Once you've instantiated one, you can use it just like you would have used the one you obtained from the <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/gg696542(v=vs.103).aspx\"");

WriteLiteral(">DbModelBuilder.Entity&lt;TEntityType&gt;()</a></code> call:</p>\r\n\r\n<pre><code");

WriteLiteral(" class=\"language-csharp\"");

WriteLiteral(@">DepartmentTypeConfiguration departmentConfig = new DepartmentTypeConfiguration();
departmentConfig.Property(t =&gt; t.Name).IsRequired();</code></pre>

<p>The previous example was just to show that the custom <code>EntityTypeConfiguration</code> class works the same way as the ones you obtain by calling <code>DbModelBuilder.Entity&lt;TEntityType&gt;()</code>. Alternatively you can specify configuration code in the constructor, which is more useful because it means the configuration code will get called whenever a new instance of your <code>EntityTypeConfiguration</code> class is created (I.e., through reflection).</p>

<pre><code");

WriteLiteral(" class=\"language-csharp\"");

WriteLiteral(@">public class DepartmentTypeConfiguration : EntityTypeConfiguration&lt;Department&gt;
{
  public DepartmentTypeConfiguration()
  {
    Property(t =&gt; t.Name).IsRequired();
  }
}</code></pre>

<p>The fluent API calls (such as <code>Property()</code>) change the internal state of the <code>EntityTypeConfiguration</code> class. When all of the configuration is complete, Entity Framework reads the state of all <code>EntityTypeConfiguration</code> classes that have been registered and uses them to build the model. But back up a step, notice I said ""all <code>EntityTypeConfiguration</code> classes <em>that have been registered</em>"". There is one more step before a custom <code>EntityTypeConfiguration</code> class can be used for configuration - it has to be registered with the <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.data.entity.modelconfigurat" +
"ion.configuration.configurationregistrar(v=vs.103).aspx\"");

WriteLiteral(">ConfigurationRegistrar</a></code>. To do so, you just use the <code>DbModelBuild" +
"er.Configurations</code> property:</p>\r\n\r\n<pre><code");

WriteLiteral(" class=\"language-csharp\"");

WriteLiteral(@">modelBuilder.Configurations.Add(departmentConfig);</code></pre>

<p>This adds the custom <code>EntityTypeConfiguration</code> instance to the list of configurations that will be used to build the final model. At this point, we could just reflect over the assembly looking for <code>EntityTypeConfiguration</code> classes, instantiating them, and adding them to the <code>ConfigurationRegistrar</code> (<a");

WriteLiteral(" href=\"http://areaofinterest.wordpress.com/2010/12/08/dynamically-load-entity-con" +
"figurations-in-ef-codefirst-ctp5/\"");

WriteLiteral(">as described by Jonas Cannehag</a>):</p>\r\n\r\n<pre><code");

WriteLiteral(" class=\"language-csharp\"");

WriteLiteral(@">var typesToRegister = Assembly.GetAssembly(typeof(YourDbContext)).GetTypes()
  .Where(type =&gt; type.Namespace != null
    &amp;&amp; type.Namespace.Equals(typeof(YourDbContext).Namespace))
  .Where(type =&gt; type.BaseType.IsGenericType
    &amp;&amp; type.BaseType.GetGenericTypeDefinition() == typeof(EntityTypeConfiguration&lt;&gt;));

foreach (var type in typesToRegister)
{
  dynamic configurationInstance = Activator.CreateInstance(type);
  modelBuilder.Configurations.Add(configurationInstance);
}</code></pre>

<p>This will allow you to create as many custom EntityTypeConfiguration classes as you need for each entity in your model. However, there are some limitations:</p>

");

            
            #line 55 "..\..\Views\Blog\Posts\custom-entity-type-configurations-in-entity-framework-code-first-part-1.cshtml"
 using (var list = Bootstrap.List(FluentBootstrap.Typography.ListType.Unordered).AddCss("p"))
{
	using(list.ListItem())
    {

            
            #line default
            #line hidden
WriteLiteral("        ");

WriteLiteral("The <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/gg696203(v=vs.103).aspx\"");

WriteLiteral(@">ConfigurationRegistrar.Add()</a></code> method only allows one <code>EntityTypeConfiguration</code> class per entity type. This may be a problem in complex models if you have some configurations for a given entity spread out in multiple places (for example, you want to place the responsibility of configuring relationships for a given entity near the entities on the other side of the relationships).");

WriteLiteral("\r\n");

            
            #line 60 "..\..\Views\Blog\Posts\custom-entity-type-configurations-in-entity-framework-code-first-part-1.cshtml"
    }
    using (list.ListItem())
    { 

            
            #line default
            #line hidden
WriteLiteral("\t    ");

WriteLiteral(@"I personally find the idea of placing configuration code inside the constructor of a dedicated class a little awkward. I would prefer to have my custom configurations specified through an interface that I could implement right on the entity, or perhaps use more than once to specify configuration for multiple entities in a single configuration class. That would give more flexibility.");

WriteLiteral("\r\n");

            
            #line 64 "..\..\Views\Blog\Posts\custom-entity-type-configurations-in-entity-framework-code-first-part-1.cshtml"
    }
}

            
            #line default
            #line hidden
WriteLiteral("\r\n<p>In ");

            
            #line 67 "..\..\Views\Blog\Posts\custom-entity-type-configurations-in-entity-framework-code-first-part-1.cshtml"
 Write(Html.Post("my next post", x => x.custom_entity_type_configurations_in_entity_framework_code_first_part_2));

            
            #line default
            #line hidden
WriteLiteral(" I\'ll discuss an alternate method of specifying custom entity type configurations" +
" that builds on this technique and addresses these two points.</p>\r\n");

        }
    }
}
#pragma warning restore 1591
