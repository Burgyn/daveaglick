#pragma warning disable 1591
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Somedave.Views.Blog.Posts
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Text;
    using System.Web;
    using System.Web.Helpers;
    using System.Web.Mvc;
    using System.Web.Mvc.Ajax;
    using System.Web.Mvc.Html;
    using System.Web.Routing;
    using System.Web.Security;
    using System.Web.UI;
    using System.Web.WebPages;
    using FluentBootstrap;
    using Somedave;
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
    [System.Web.WebPages.PageVirtualPathAttribute("~/Views/Blog/Posts/introducing-nicethreads.cshtml")]
    public partial class introducing_nicethreads : Somedave.BlogPostViewPage<dynamic>
    {
        public introducing_nicethreads()
        {
        }
        public override void Execute()
        {
            
            #line 1 "..\..\Views\Blog\Posts\introducing-nicethreads.cshtml"
  
    Title = "Introducing NiceThreads";
    Lead = "A threading utility library designed to make different threading primitives easier to use.";
    Published = new DateTime(2012, 2, 17);
    Tags = new[] { "NiceThreads", "Threading", "Monitor", "ReaderWriterLockSlim", "locking", "ILocker" };

            
            #line default
            #line hidden
WriteLiteral(@"

<p>NiceThreads is threading utility library designed to make different threading primitives easier to use with a more consistent API. It started out of frustration with the different options (and more specifically, the different APIs) for enabling thread safety and locks in the .NET framework and how much code was required to use some of them. NiceThreads provides a consistent interface for standard <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.threading.monitor.aspx\"");

WriteLiteral(">Monitor</a></code> locks and the <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.threading.readerwriterlocks" +
"lim.aspx\"");

WriteLiteral(">ReaderWriterLockSlim</a></code> class (and possibly others in the future). It al" +
"so provides support for activating and deactivating these locking primitives thr" +
"ough the <a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.idisposable.aspx\"");

WriteLiteral(@">disposable pattern</a>. Finally, it provides wrappers that can easily provide thread-safety to unsafe objects.</p>
<h1>Common API</h1>
<p>Both <code>Monitor</code> (and the ""lock"" statement which is syntactic sugar for <code>Monitor</code>) and <code>ReaderWriterLockSlim</code> attempt to solve the same problem: preventing conflicting concurrent access to objects that might need to be read or written to by multiple threads. They both do this by limiting access to the object to one thread at a time (or in the case of read locks provided by <code>ReaderWriterLockSlim</code>, only to threads that signal they want read-only access) while making other threads wait their turn. However, even though both classes provide similar functionality they are intended for different uses and have <a");

WriteLiteral(" href=\"http://blogs.msdn.com/b/pedram/archive/2007/10/07/a-performance-comparison" +
"-of-readerwriterlockslim-with-readerwriterlock.aspx\"");

WriteLiteral(@">different tradeoffs</a>. Further, they use similar but different APIs making switching between them difficult.</p>
<p>To solve this problem, NiceThreads provides a consistent ILocker interface that has implementations wrapping both classes and provides a consistent API. The rest of NiceThreads is designed to interact with <code>ILocker</code> allowing interchangeable use of the different types of locking primitives. In addition, the <code>ILocker</code> interface can be used directly to provide a consistent wrapper around either locking class for your own code.</p>
<p>For example:</p>
<pre><code");

WriteLiteral(" class=\"language-csharp\"");

WriteLiteral(">ILocker locker = new ReaderWriterLockSlimLocker();\r\nlocker.EnterReadLock();\r\n// " +
"Do work...\r\nlocker.ExitReadLock();\r\nlocker = new MonitorLocker();\r\nlocker.EnterR" +
"eadLock();\r\n// Do work...\r\nlocker.ExitReadLock();</code></pre>\r\n<h1>Disposable P" +
"attern</h1>\r\n<p>Both locking primitives require explicitly activating the lock a" +
"nd subsequently manually removing the lock when finished. This can lead to probl" +
"ems if the developer forgets to release the lock or ends up exiting the normal p" +
"rogram flow (for example, because an exception was thrown). The <code>lock</code" +
"> keyword in C# attempts to make this design easier to use for the <code>Monitor" +
"</code> class by abstracting <code>Monitor</code> instantiation and surrounding " +
"it\'s use in a control block, however, no such keyword exists for other locking c" +
"lasses such as <code>ReaderWriterLockSlim</code>. In addition, using the <code>l" +
"ock</code> keyword means some control is lost over the lifecycle and usage of th" +
"e underlying <code>Monitor</code> class.</p>\r\n<p>NiceThreads attempts to solve t" +
"his problem by providing a set of classes that implement <code>IDisposable</code" +
"> and wraps an underlying <code>ILocker</code> (which in turn provides consisten" +
"t access to alternate framework locking classes). They activate the requested lo" +
"ck type on instantiation and free it on disposal. This allows the developer to u" +
"se the built-in support for the disposable pattern in .NET to automatically free" +
" a lock when finished with it by using the <code>using</code> statement.</p>\r\n<p" +
">For example:</p>\r\n<pre><code");

WriteLiteral(" class=\"language-csharp\"");

WriteLiteral(@">ILocker locker = new ReaderWriterLockSlimLocker();
using(new ReadLock(locker))
{
  // Do work...
}</code></pre>
<h1>Thread-Safe Wrappers</h1>
<p>Even with the added convenience of a consistent API and disposable pattern support, implementing thread-safety for non-thread-safe objects can still require a fair amount of code. For every object that needs to be protected, a new locking object potentially needs to be created and maintained. NiceThreads helps implement thread safety for objects by providing wrapper classes that encapsulate generic locking logic and provide thread-safe access to their underlying object. <code>SyncObject&lt;T&gt;</code> wraps an arbitrary type and <code>ReadOnlySyncObject&lt;T&gt;</code> wraps an arbitrary type while providing ""readonly"" semantics (I.e., once the <code>ReadOnlySyncObject&lt;T&gt;</code> has been constructed, it's underlying object cannot be changed). These classes provide a variety of methods to expose their wrapped object in thread-safe ways including thread-safe getting and setting, disposable pattern access, and action/function providers (I.e., lambdas or anonymous methods).</p>
<p>For example:</p>
<pre><code");

WriteLiteral(" class=\"language-csharp\"");

WriteLiteral(@">SyncObject&lt;int&gt; num = new SyncObject&lt;int&gt;(10);
num.Sync = 20; // Access as a property with a thread-safe setter
int value = num.Sync; // Access as a property with a thread-safe getter
using(num.WriteLock())
{
 // We can now access using unsafe code
 num.UnsyncField++; // Provides direct field access
 value = num.Unsync; // Access as a property with an unsafe getter
}
num.DoWrite(n => n + 10); // Thread-safe write with an Action
value = num.DoRead(n => n + 100); // Thread-safe read with a Func
</code></pre>
<h1>Obtaining</h1>
<p>NiceThreads is open source and released under the Apache 2.0 license. It can be obtained here: <a");

WriteLiteral(" href=\"https://github.com/somedave/NiceThreads\"");

WriteLiteral(">https://github.com/somedave/NiceThreads</a></p>\r\n");

        }
    }
}
#pragma warning restore 1591
