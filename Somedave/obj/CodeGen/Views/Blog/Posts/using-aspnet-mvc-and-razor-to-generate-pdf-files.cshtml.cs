#pragma warning disable 1591
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Somedave.Views.Blog.Posts
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Text;
    using System.Web;
    using System.Web.Helpers;
    using System.Web.Mvc;
    using System.Web.Mvc.Ajax;
    using System.Web.Mvc.Html;
    using System.Web.Routing;
    using System.Web.Security;
    using System.Web.UI;
    using System.Web.WebPages;
    using FluentBootstrap;
    using Somedave;
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("RazorGenerator", "2.0.0.0")]
    [System.Web.WebPages.PageVirtualPathAttribute("~/Views/Blog/Posts/using-aspnet-mvc-and-razor-to-generate-pdf-files.cshtml")]
    public partial class using_aspnet_mvc_and_razor_to_generate_pdf_files : Somedave.BlogPostViewPage<dynamic>
    {
        public using_aspnet_mvc_and_razor_to_generate_pdf_files()
        {
        }
        public override void Execute()
        {
            
            #line 1 "..\..\Views\Blog\Posts\using-aspnet-mvc-and-razor-to-generate-pdf-files.cshtml"
  
    Title = "Using ASP.NET MVC and Razor To Generate PDF Files";
    Published = new DateTime(2014, 5, 9);
    Tags = new[] { "ASPNET", "ASPNET MVC", "export", "PDF", "Acrobat" };

            
            #line default
            #line hidden
WriteLiteral("\r\n\r\n<p>From reports to scan sheets, the need to generate PDF files has been prese" +
"nt in every line-of-business application I’ve ever worked on. In the past, I’ve " +
"used a variety of tools to achieve this such as <a");

WriteLiteral(" href=\"http://en.wikipedia.org/wiki/SQL_Server_Reporting_Services\"");

WriteLiteral(">SQL Server Reporting Services</a> or <a");

WriteLiteral(" href=\"http://www.telerik.com/products/reporting.aspx\"");

WriteLiteral(@">Telerik Reporting</a>. While these kinds of tools work well enough for generating reports straight from the database, it’s been surprising how few resources exist to aid in generating PDF files from arbitrary data.</p>

<p>It turns out there is a pretty simple way to enable the generation of PDF files in an ASP.NET MVC application using the same Razor view engine that you’re probably already using. This allows you to make use of view models, HTML helpers, etc. in your PDF logic. The code here is based primarily on the code in MVC itself, specifically the <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.actionresult(v=vs.1" +
"18).aspx\"");

WriteLiteral(">ActionResult</a></code> and <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.viewresult(v=vs.118" +
").aspx\"");

WriteLiteral(">ViewResult</a></code> classes. It’s also based on general concepts used in two o" +
"pen source projects, <a");

WriteLiteral(" href=\"https://github.com/andyhutch77/MvcRazorToPdf\"");

WriteLiteral(">MvcRazorToPdf</a> and <a");

WriteLiteral(" href=\"https://github.com/RazorAnt/RazorPDF\"");

WriteLiteral(">RazorPDF</a>. In a nutshell, the commands necessary to create a given PDF file (" +
"typically as XML) are placed in a standard .cshtml view, rendered and interprete" +
"d as any Razor view would be, passed to a PDF generation library (I use the exce" +
"llent <a");

WriteLiteral(" href=\"http://www.aspose.com/.net/pdf-component.aspx\"");

WriteLiteral(">Aspose.Pdf</a>, but this approach can also work with <a");

WriteLiteral(" href=\"http://sourceforge.net/projects/itextsharp/\"");

WriteLiteral(">iTextSharp</a> or any other PDF generation library that takes markup such as XML" +
"), and then returned to the client as PDF content. This is what the process look" +
"s like in a nutshell:</p>\r\n\r\n");

            
            #line 11 "..\..\Views\Blog\Posts\using-aspnet-mvc-and-razor-to-generate-pdf-files.cshtml"
Write(Bootstrap.Image(Links.Content.posts.pdf_process_png).Responsive());

            
            #line default
            #line hidden
WriteLiteral(@"

<h1>The PdfResult Class</h1>

<p>The <code>PdfResult</code> class is the heart of this approach. It contains all of the logic necessary to locate the view, set up the view context, render the view, and generate the PDF file. Though it does all the heavy lifting, there actually isn’t that much code involved:</p>

<pre><code");

WriteLiteral(" class=\"language-csharp\"");

WriteLiteral(">public class PdfResult : PartialViewResult\r\n{\r\n    // Setting a FileDownloadName" +
" downloads the PDF instead of viewing it\r\n    public string FileDownloadName { g" +
"et; set; }\r\n\r\n    public override void ExecuteResult(ControllerContext context)\r" +
"\n    {\r\n        if (context == null)\r\n        {\r\n            throw new ArgumentN" +
"ullException(\"context\");\r\n        }\r\n\r\n        // Set the model and data\r\n      " +
"  context.Controller.ViewData.Model = Model;\r\n        ViewData = context.Control" +
"ler.ViewData;\r\n        TempData = context.Controller.TempData;\r\n\r\n\r\n        // G" +
"et the view name\r\n        if (string.IsNullOrEmpty(ViewName))\r\n        {\r\n      " +
"      ViewName = context.RouteData.GetRequiredString(\"action\");\r\n        }\r\n\r\n  " +
"      // Get the view\r\n        ViewEngineResult viewEngineResult = null;\r\n      " +
"  if (View == null)\r\n        {\r\n            viewEngineResult = FindView(context)" +
";\r\n            View = viewEngineResult.View;\r\n        }\r\n\r\n        // Render the" +
" view\r\n        StringBuilder sb = new StringBuilder();\r\n        using (TextWrite" +
"r tr = new StringWriter(sb))\r\n        {\r\n            ViewContext viewContext = n" +
"ew ViewContext(context, View, ViewData, TempData, tr);\r\n            View.Render(" +
"viewContext, tr);\r\n        }\r\n        if (viewEngineResult != null)\r\n        {\r\n" +
"            viewEngineResult.ViewEngine.ReleaseView(context, View);\r\n        }\r\n" +
"\r\n        // Create a PDF from the rendered view content\r\n        Aspose.Pdf.Gen" +
"erator.Pdf pdf = new Aspose.Pdf.Generator.Pdf();\r\n        using (MemoryStream ms" +
" = new MemoryStream(Encoding.UTF8.GetBytes(sb.ToString())))\r\n        {\r\n        " +
"    pdf.BindXML(ms, null);\r\n        }\r\n\r\n        // Save the PDF to the response" +
" stream\r\n        using(MemoryStream ms = new MemoryStream())\r\n        {\r\n       " +
"     pdf.Save(ms);\r\n            FileContentResult result = new FileContentResult" +
"(ms.ToArray(), \"application/pdf\")\r\n            {\r\n                FileDownloadNa" +
"me = FileDownloadName\r\n            };\r\n            result.ExecuteResult(context)" +
";\r\n        }\r\n    }\r\n}</code></pre>\r\n\r\n<p>Let’s go through this from top to bott" +
"om.</p>\r\n\r\n<p>First off, it’s derived from <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.partialviewresult(v" +
"=vs.118).aspx\"");

WriteLiteral(">PartialViewResult</a></code>. Why <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.partialviewresult(v" +
"=vs.118).aspx\"");

WriteLiteral(">PartialViewResult</a></code> and not <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.viewresult(v=vs.118" +
").aspx\"");

WriteLiteral(">ViewResult</a></code> or <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.actionresult(v=vs.1" +
"18).aspx\"");

WriteLiteral(">ActionResult</a></code>? <code>ViewResult</code> has a more robust implementatio" +
"n of <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.viewresult.findview" +
"(v=vs.118).aspx\"");

WriteLiteral(">FindView()</a></code> that looks in several places for the view and includes the" +
" convention-based view search logic we’re used to using with normal views. It al" +
"so includes built-in support for managing the <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.viewresultbase.view" +
"data(v=vs.118).aspx\"");

WriteLiteral(">ViewData</a></code> for a view. So why use <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.partialviewresult(v" +
"=vs.118).aspx\"");

WriteLiteral(">PartialViewResult</a></code>? The reason is that <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.partialviewresult(v" +
"=vs.118).aspx\"");

WriteLiteral(">PartialViewResult</a></code> never attempts to render layouts as part of the vie" +
"w. This is important if you’re using a global layout via a <a");

WriteLiteral(" href=\"http://weblogs.asp.net/scottgu/archive/2010/10/22/asp-net-mvc-3-layouts.as" +
"px\"");

WriteLiteral(@">_ViewStart.cshtml</a> file or something similar. Since our PDF file obviously shouldn’t have the same layout logic as one of our actual web pages, we need to make sure that doesn’t get included in the rendered PDF syntax. The easiest way to do that is to derive our <code>PdfResult</code> class from <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.partialviewresult(v" +
"=vs.118).aspx\"");

WriteLiteral(">PartialViewResult</a></code>, which ensures a layout is not used by returning a " +
"slightly different <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.viewengineresult(v=" +
"vs.118).aspx\"");

WriteLiteral(">ViewEngineResult</a></code> (and thus <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.iview(v=vs.118).asp" +
"x\"");

WriteLiteral(">IView</a></code>) in it’s own <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.partialviewresult.f" +
"indview(v=vs.118).aspx\"");

WriteLiteral(">FindView()</a></code> implementation.</p>\r\n\r\n<p>Looking at the body, the only me" +
"thod is an override of <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.actionresult.execut" +
"eresult(v=vs.118).aspx\"");

WriteLiteral(">ExecuteResult()</a></code>. This method is called when the <code>PdfResult</code" +
"> (or any <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.actionresult(v=vs.1" +
"18).aspx\"");

WriteLiteral(@">ActionResult</a></code>) is processed by MVC and is intended to manipulate the result sent to the client (by adding content, setting headers, etc.). The first thing we do is check to make sure we have a context. This block, and most of the rest of the first part of the method, is copied straight from the implementation in MVC. Next we set the model (if there is one) and the other data that will be passed to the view. This is necessary to make sure that when we interpret our view code we have access to all of the same kinds of data we would have if this were just a normal web view. Then we get the name of the view from the action name if a view name wasn’t already provided. We set this in the <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.viewresultbase.view" +
"name(v=vs.118).aspx\"");

WriteLiteral(">ViewName</a></code> member which <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.partialviewresult.f" +
"indview(v=vs.118).aspx\"");

WriteLiteral(">FindView()</a></code> uses to locate the view.</p>\r\n\r\n<p>This is where things ge" +
"t a little bit interesting. Next we call <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.partialviewresult.f" +
"indview(v=vs.118).aspx\"");

WriteLiteral(">FindView()</a></code> which locates the actual view .cshtml file using MVC conve" +
"ntions and instantiates an <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.iview(v=vs.118).asp" +
"x\"");

WriteLiteral(">IView</a></code> for us that can be used for rendering the view. We then create " +
"a <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.viewcontext(v=vs.11" +
"8).aspx\"");

WriteLiteral(">ViewContext</a></code> to hold all of the data our view might need and call the " +
"<code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.iview.render(v=vs.1" +
"18).aspx\"");

WriteLiteral(">Render()</a></code> method of the <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.iview(v=vs.118).asp" +
"x\"");

WriteLiteral(@">IView</a></code> we were previously provided. This triggers the Razor view engine and is where the view magically gets transformed into content we can pass to our PDF generation library.</p>

<p>Once we have the content to pass to the PDF generator library, we create the PDF file. The code above is written for <a");

WriteLiteral(" href=\"http://www.aspose.com/.net/pdf-component.aspx\"");

WriteLiteral(">Aspose.Pdf</a>, but could be adapted to work with <a");

WriteLiteral(" href=\"http://sourceforge.net/projects/itextsharp/\"");

WriteLiteral(">iTextSharp</a> like this (from <a");

WriteLiteral(" href=\"https://github.com/andyhutch77/MvcRazorToPdf\"");

WriteLiteral(">MvcRazorToPdf</a>):</p>\r\n\r\n<pre><code");

WriteLiteral(" class=\"language-csharp\"");

WriteLiteral(@">// Create a PDF from the rendered view content
var workStream = new MemoryStream();
var document = new Document();
PdfWriter writer = PdfWriter.GetInstance(document, workStream);
writer.CloseStream = false;
document.Open();
Stream stream = new MemoryStream(Encoding.UTF8.GetBytes(sb.ToString()));
XMLWorkerHelper.GetInstance().ParseXHtml(writer, document, stream, null);
document.Close();

// Save the PDF to the response stream
FileContentResult result = new FileContentResult(workStream.ToArray(), ""application/pdf"")
{
    FileDownloadName = FileDownloadName
};
</code></pre>

<p>One final note about the <code>FileDownloadName</code> property and it’s use in the <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.filecontentresult(v" +
"=vs.118).aspx\"");

WriteLiteral(@">FileContentResult</a></code>. If <code>null</code> is supplied for <code>FileDownloadName</code>, the PDF file will be delivered to the browser and rendered inline. However, if a value is supplied for <code>FileDownloadName</code>, the browser will initiate a file download of a PDF file with that name. This lets you control the way in which the client views and downloads the PDF file.</p>

<h1>The Controller</h1>

<p>Now that we have the <code>PdfResult</code> class complete, how do we use it to actually generate a PDF file? This step is optional, but I prefer to add a method to my <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.controller(v=vs.118" +
").aspx\"");

WriteLiteral(">Controller</a></code> base class to support alternate view results from an actio" +
"n. <a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/dd460331(v=vs.118).aspx\"");

WriteLiteral(">The base <code>Controller</code> in MVC already does this</a> – you typically wr" +
"ite <code>return View();</code> not <code>return new ViewResult() { ... };</code" +
"> If you don’t already have a custom base <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.controller(v=vs.118" +
").aspx\"");

WriteLiteral(">Controller</a></code> in your MVC application, I suggest adding one. Even if it’" +
"s just to hold the next bit of code, it’s worthwhile. And I’ve found over time t" +
"hat it’s nice having a base <code><a");

WriteLiteral(" href=\"http://msdn.microsoft.com/en-us/library/system.web.mvc.controller(v=vs.118" +
").aspx\"");

WriteLiteral(">Controller</a></code> class into which I can add all sorts of other helper metho" +
"ds and additional logic. To that end, the following are overloads for a <code>Pd" +
"f()</code> method that can be used as the return value for an action:</p>\r\n\r\n<pr" +
"e><code");

WriteLiteral(" class=\"language-csharp\"");

WriteLiteral(@">protected ActionResult Pdf()
{
    return Pdf(null, null, null);
}

protected ActionResult Pdf(string fileDownloadName)
{
    return Pdf(fileDownloadName, null, null);
}

protected ActionResult Pdf(string fileDownloadName, string viewName)
{
    return Pdf(fileDownloadName, viewName, null);
}

protected ActionResult Pdf(object model)
{
    return Pdf(null, null, model);
}

protected ActionResult Pdf(string fileDownloadName, object model)
{
    return Pdf(fileDownloadName, null, model);
}

protected ActionResult Pdf(string fileDownloadName, string viewName, object model)
{
    // Based on View() code in Controller base class from MVC
    if (model != null)
    {
        ViewData.Model = model;
    }
    PdfResult pdf = new PdfResult()
    {
        FileDownloadName = fileDownloadName,
        ViewName = viewName,
        ViewData = ViewData,
        TempData = TempData,
        ViewEngineCollection = ViewEngineCollection
    };
    return pdf;
}</code></pre>

<h1>The Action</h1>

<p>The result of all this is that you can write you PDF generating actions in a very similar way to how you write your normal web actions:</p>

<pre><code");

WriteLiteral(" class=\"language-csharp\"");

WriteLiteral(@">public virtual ActionResult PdfTest()
{

    return Pdf(new int[] { 1, 2, 3 });

}
</code></pre>

<p>The code about will cause a <code>PdfResult</code> class to be instantiated which will attempt to find a view named “PdfTest.cshtml” in the conventional location. It will be given an <code>int[]</code> array as it’s model and then rendered by the Razor view engine.</p>

<h1>The View</h1>

<p>The final step is the view, where the actual PDF content is specified. Recall that I said I’m using <a");

WriteLiteral(" href=\"http://www.aspose.com/.net/pdf-component.aspx\"");

WriteLiteral(">Aspose.Pdf</a>, so the XML in my view corresponds to the XML that <a");

WriteLiteral(" href=\"http://www.aspose.com/.net/pdf-component.aspx\"");

WriteLiteral(">Aspose.Pdf</a> expects. If you’re using <a");

WriteLiteral(" href=\"http://sourceforge.net/projects/itextsharp/\"");

WriteLiteral(">iTextSharp</a> or any other PDF generation library then the XML (or other type o" +
"f) content contained in your view may look drastically different. But for the sa" +
"ke of example, here’s what a sample view might look like using the <a");

WriteLiteral(" href=\"http://www.aspose.com/.net/pdf-component.aspx\"");

WriteLiteral(">Aspose.Pdf</a> XML format:</p>\r\n\r\n<pre><code");

WriteLiteral(" class=\"language-csharp\"");

WriteLiteral(">");

WriteLiteral("@model IEnumerable&lt;int&gt;\r\n\r\n&lt;Pdf xmlns=&quot;Aspose.Pdf&quot; Destination" +
"Type=&quot;FitPage&quot;&gt;\r\n    &lt;Section&gt;\r\n        ");

WriteLiteral("@foreach (int c in Model)\r\n        {\r\n            ");

WriteLiteral("@:&lt;Text Alignment=&quot;Center&quot;&gt;&lt;Segment&gt;");

WriteLiteral(@"@c&lt;/Segment&gt;&lt;/Text&gt;       
        }
    &lt;/Section&gt;
&lt;/Pdf&gt;</code></pre>

<p>The Razor syntax checker in Visual Studio will probably complain that all these XML elements are not valid HTML5 (or whatever other validation type you have configured), but that’s fine – the actual view engine will deal with them without issue. One small complication you’ll see above is that the <a");

WriteLiteral(" href=\"http://www.aspose.com/.net/pdf-component.aspx\"");

WriteLiteral(">Aspose.Pdf</a> XML specification uses an element called <code>Text</code>. <a");

WriteLiteral(" href=\"http://weblogs.asp.net/scottgu/archive/2010/12/15/asp-net-mvc-3-razor-s-an" +
"d-lt-text-gt-syntax.aspx\"");

WriteLiteral(">Unfortunately, this element also has a very special meaning in Razor syntax</a>." +
" We need to escape it when used directly inside a code block by using <code>");

WriteLiteral(@"@:</code>.</p>

<h1>Conclusion</h1>

<p>That about covers it. This was a pretty long article, mainly because I wanted to explain how everything fit together. Hopefully you’ll see that when you get right down to it the approach is actually pretty simple. Now go forth and populate your web apps with lots of useful PDF documents.</p>");

        }
    }
}
#pragma warning restore 1591
