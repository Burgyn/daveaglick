Title: The Bleeding Edge Of Razor
Lead: Using the Razor view engine in your own code.
Published: 10/4/2018
Image: /images/blocks.jpg
Tags:
  - ASP.NET
  - ASP.NET MVC
  - Razor
---
Over the years there's been a number of projects designed to make using Razor templates from your own code easier. For a while, these third-party libraries were the only way to easily use Razor outside ASP.NET MVC because using the ASP.NET code directly was too complicated. That started to change with ASP.NET Core and the ASP.NET team has slowly started to address this use case. In this post we'll take a look at the current bleeding edge of Razor and how you can use it today to enable template rendering in your own application.

Before we start looking at code, let's back up a step and consider what Razor is (and what it isn't). At it's core, Razor is a templating language. Templating languages are designed to make producing output content easier by intermixing raw output with instructions on how to generate additional programmatically-based output. In this case, Razor is used to produce HTML documents. An important distinction that I want to make here is that Razor _is not_ the set of HTML helpers and other support functionality that comes along with ASP.NET MVC. For example, helpers like `Html.Partial()` and page directives like `@section` aren't part of the Razor language. Instead they're shipped with ASP.NET MVC as additional support on top of Razor, which your Razor code can use.

This distinction wasn't always clear, but recently the ASP.NET team has been focusing on separating Razor _the language_ from Razor _for ASP.NET MVC_. This is partly out of necessity as Razor has grown to support at least three different dialects (ASP.NET MVC, Razor Pages, and Blazor), but it also makes using Razor for your own purposes easier too.

# Rendering Phases

Turning Razor content from a string, file, or other source into final rendered HTML requires several phases:

* Generating C# code from the template
* Compiling the C# code into an assembly
* Loading the assembly into memory
* Executing your compiled template

I'll discuss each phase in more detail below. Before I do, note that Razor is under heavy development (and has been for a while). Even though a lot of the API is surfaced as public, it's been known to break in subtle ways between releases. On top of that, I learned most of this through trial-and-error and reverse engineering and make no assurances that this is the canonical way or even a correct way of doing any of this. You've been warned.

## Generating Code

A Razor template starts life as a string (or file) with intermixed HTML, C# code, and Razor directives. You can think of this template as a little program that takes input like your page model and outputs the resulting HTML. Like any program it needs to be compiled and executed. The first part of this process essentially "inverts" the HTML and C# code in the template and creates C# code that "prints" the HTML parts of your template along with the raw code that you added to your template.

This phase is where a lot of the recent work in Razor has been focused. It used to be that the process of converting a Razor template to C# code happened as part of the overall MVC Razor processing. Now, a series of libraries under `Microsoft.AspNetCore.Razor.Language` separates Razor _the language_ from Razor _for ASP.NET MVC_.

Here's how to take a Razor template stored in the file `C:\Code\RazorExample\date.cshtml` and generate C# from it (you'll need to add the `Microsoft.AspNetCore.Razor.Language` package to get access to these classes):

```
RazorConfiguration config = RazorConfiguration.Default;
RazorProjectFileSystem projectFileSystem =
  RazorProjectFileSystem.Create(@"C:\Code\RazorExample");
RazorProjectEngine projectEngine =
  RazorProjectEngine.Create(config, projectFileSystem);
RazorProjectItem projectItem = projectFileSystem.GetItem("date.cshtml");
RazorTemplateEngine templateEngine =
  new RazorTemplateEngine(projectEngine.Engine, projectFileSystem);
RazorCodeDocument codeDocument = templateEngine.CreateCodeDocument(projectItem);
RazorCSharpDocument cSharpDocument = templateEngine.GenerateCode(codeDocument);         
```

Given a `data.cshtml` file that looks like this:

```
<p>@DateTime.Now</p>
```

This will produce the following C# code in `cSharpDocument.GeneratedCode`:

```
#pragma checksum "E:\Code\NewRazor\date.cshtml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "7dea33102781d0fc7059874abc785e31de14ef37"
// <auto-generated/>
#pragma warning disable 1591
[assembly: global::Microsoft.AspNetCore.Razor.Hosting.RazorCompiledItemAttribute(typeof(Razor.Template), @"default", @"/date.cshtml")]
namespace Razor
{
    #line hidden
    [global::Microsoft.AspNetCore.Razor.Hosting.RazorSourceChecksumAttribute(@"SHA1", @"7dea33102781d0fc7059874abc785e31de14ef37", @"/date.cshtml")]
    public class Template
    {
        #pragma warning disable 1998
        public async override global::System.Threading.Tasks.Task ExecuteAsync()
        {
            WriteLiteral("<p>");
#line 1 "E:\Code\NewRazor\date.cshtml"
Write(DateTime.Now);

#line default
#line hidden
            WriteLiteral("</p>");
        }
        #pragma warning restore 1998
    }
}
#pragma warning restore 1591
```

Let's break that down just a little bit...

The `RazorProjectFileSystem` is responsible for presenting available files and their content to the Razor engine. It's primary job is to create `RazorProjectItem` instances given a path. These `RazorProjectItem` objects contain metadata about the requested file as well as access to a `Stream` (if the file exists). The default `RazorProjectFileSystem` obtained by the call to `RazorProjectFileSystem.Create(string root)` is aptly named `DefaultRazorProjectFileSystem` and wraps `System.IO` classes like `FileInfo` and `FileStream`. If you want to access files differently (like from a database), you'll need to implement your own `RazorProjectFileSystem` and `RazorProjectItem`.

The `RazorProjectEngine` is the workhorse here. It slices up your template, applies a sequence of processing phases to it to construct a syntax tree, and then lowers that syntax tree into C#. If you need to adjust the way Razor generates your code, it'll probably be through the `RazorProjectEngine`. In future posts I'll probably take a look at some of these possibilities.

Like the `RazorProjectEngine`, the `RazorTemplateEngine` also participates in generating code. It's main job is essentially to add imports and other required functionality to your generated code and then defer to the `RazorProjectEngine` for processing of the syntax tree.

Finally, `RazorCodeDocument` contains the abstract representation of your template and `RazorCSharpDocument` contains the final produced C# code.

## Compiling The Code

Now that we have some C# code, we need to compile it. The Razor language bits are done (at least for now) and we'll use Roslyn to compile our code.

## Loading The Assembly

## Executing The Template

# Bringing It All Together

# But What About MVC

If you start adding MVC conventions to your templates, you'll notice they either result in failures or just plain don't work. For example, if you add a layout to your template:

The layout simply won't be rendered. That's because...