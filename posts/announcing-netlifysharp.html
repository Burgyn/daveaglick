<p><a href="https://www.netlify.com/">Netlify</a> is an awesome static site host with tons of developer-friendly features including a <a href="https://www.netlify.com/docs/api/">comprehensive API</a>. Today I'm announcing <a href="https://netlifysharp.netlify.com/">NetlifySharp</a>, a new .NET API client for that API that lets you control your Netlify sites from .NET.</p>
<p>Building NetlifySharp was a fun experience for me. I've written plenty of REST client code, but I've never written a .NET client for a REST API that's designed to be consumed by other developers. Questions like &quot;how can I allow customization?&quot; were interesting to ponder. In the end I think I struck a pretty good balance between exposing an easy to use API while allowing more control if desired.</p>
<p>One aspect of this project that was mostly new to me is Open API. I was familiar with the concept but hadn't gone much beyond that. Since Netlify publishes an <a href="https://open-api.netlify.com/">Open API specification</a> it was the perfect opportunity to learn. I ended up doing more than that though - as I got tired of writing model code for the API request and response bodies, I ended up using <a href="https://github.com/daveaglick/Scripty">Scripty</a> to write a lightweight Open API parser to generate the model definitions for me from the specification. It's certainly not general enough to release as an all-purpose Open API client generator (we already have <a href="https://github.com/RSuter/NSwag">NSwag</a> and <a href="https://github.com/Azure/autorest">AutoRest</a> for that) it served my purposes quite well.</p>
<p>Regarding <a href="https://github.com/RSuter/NSwag">NSwag</a> and <a href="https://github.com/Azure/autorest">AutoRest</a>, I looked at both to see if they would fit my needs. Why spend time writing a client API when you can issue a few commands and generate one? Unfortunatly, neither really felt natural to me. I'm sure the clients would have worked fine but they were lacking that personal touch that comes from a bespoke artisinal API.</p>
<h1 id="usage">Usage</h1>
<p>All operations are performed through a <code>NetlifyClient</code> instance. Use <a href="https://app.netlify.com/account/applications">a personal access token</a> to create the client:</p>
<pre><code>NetlifyClient client = new NetlifyClient(&quot;123456789abcdef&quot;);
</code></pre>
<p>The <code>NetlifyClient</code> contains methods for each of the endpoints. All endpoints are asynchronous and use a fluent interface. You must call <code>.SendAsync()</code> to initiate communication with the Netlify API.</p>
<p>For example, to get a list of all configured sites for the account:</p>
<pre><code>IEnumerable&lt;Site&gt; sites = await client.ListSites().SendAsync();
</code></pre>
<p>To create a new site:</p>
<pre><code>Site site = await client
    .CreateSite(
        new SiteSetup(client)
        {
            Name = &quot;mynewsite&quot;
        })
    .SendAsync();
</code></pre>
<p>You'll notice that the <code>NetlifyClient</code> instance was required in the <code>SiteSetup</code> constructor in the above example. All models require the client to be provided when directly instantiating them. If they're created as a result of an API call (like the sites in the first example) then the client is already set. This is so every model can initiate their own API requests through the client.</p>
<p>For example, to delete an existing site:</p>
<pre><code>Site deleteme = await client.GetSite(&quot;sitetodelete.netlify.com&quot;).SendAsync();
await deleteme.DeleteSite().SendAsync();
</code></pre>
<p>More information is available <a href="https://netlifysharp.netlify.com">in the docs</a>.</p>
<h1 id="current-status">Current Status</h1>
<p>Right now only the sites endpoints are implemented. That means you can query for sites, create and delete site, upload deployments, and perform other site operations. The other endpoints will be coming soon.</p>
<h1 id="but-why">But, Why?</h1>
<iframe src="https://giphy.com/embed/1M9fmo1WAFVK0" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/why-ryan-reynolds-1M9fmo1WAFVK0">via GIPHY</a></p>
<p>So a legitimate question you may have at this point is why build something like this at all? If there's a REST API and a CLI, why do we even need a .NET client? The answer is automation. The Netlify API offers a lot of interesting functionality like creating and deleting sites on the fly, reading form submissions, deploying new versions, etc. By using NetlifySharp we can add these capabilities to a <a href="https://wyam.io">static site generator</a> or <a href="https://cakebuild.net">build automation tool</a>.</p>
<p>For example, the use case I currently have in mind (and the reason I wrote this now) is to create new Netlify sites on demand as part of a complex documentation generation process that publishes documentation for different versions of a library. As the documentation generation process is fully automated, it can check if a site for a given version already exists and if it doesn't we can generate the documentation, create the Netlify site to host it, and deploy it all from a build script.</p>
<p>Another interesting use case I'm considering is using the <a href="https://www.netlify.com/docs/form-handling/">Netlify form handling</a> capabilities to replace the commenting system on my static blog. The static generation process could use NetlifySharp to query for form submissions and generate comments from them.</p>
<p>If you end up doing something cool with NetlifySharp, let me know!</p>
