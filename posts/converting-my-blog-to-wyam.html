<p>I <a href="/posts/announcing-wyam">recently launched a new static site generator</a>, and I figured what better test of whether it's ready for widespread use than to convert my entire blog to use it. Given that this blog was originally built with ASP.NET MVC, it should be a good fit for converting over to a Razor-based static site generator. The process was actually  easier than I thought it would be and suggests that <a href="https://wyam.io">Wyam</a> is already ready for production use on personal sites, blogs, etc.</p>
<p>I went into the process with a few requirements:</p>
<ul>
<li>The rendered HTML had to match the original site. I wasn't interested in redesigning things at the same time I was converting the backend.</li>
<li>I wanted to support Markdown documents as well as Razor pages (which was the only option before).</li>
<li>The new site couldn't be more complex than the old site. For example, site layouts still had to be contained in a single file, etc.</li>
</ul>
<p>I also decided that I wanted to see if I could easily support an alternate development environment that didn't involve Visual Studio (since Visual Studio wouldn't have recognized the collection of files Wyam was reading as a normal web site project anyway). I took the opportunity to really dig in to <a href="https://code.visualstudio.com/">Visual Studio Code</a> and am happy to report I have fallen in love with it as a lightweight editing alternative when you don't need a full IDE. I also fired up Wyam in a console with the command <code>Wyam.exe --watch --preview</code> and left it running in the background while I worked. That way, any time I saved a file, the site would get regenerated and I could (almost) immediately preview it in a browser using the local Wyam web server.</p>
<p>The first step was getting all the layout files to work. Because the <a href="https://wyam.io/modules/razor">Wyam Razor module</a> already supports the standard Razor layout file conventions, this mostly amounted to copying and pasting the layout and content files to the new site. Once I got the general layout working, I starting bringing over some of the non-blog pages (like <a href="/about">about</a>). These were originally Razor pages so I just left them that way. This is where I hit my first snag. The original site used a custom Razor base page to expose a page property that the views could use for easy access to <a href="http://fluentbootstrap.com">FluentBootstrap</a>. Getting <a href="http://fluentbootstrap.com">FluentBootstrap</a> into the static site wasn't hard as I had already developed a <a href="https://www.nuget.org/packages/FluentBootstrap.Wyam">NuGet package for this purpose</a>, but exposing the property so I didn't have to rewrite all my views turned out to be a challenge. To resolve this, I added support to the <a href="https://wyam.io/modules/razor">Wyam Razor module</a> for specifying base pages and then created my base page class right in the Wyam config file for the site:</p>
<pre><code>public abstract class RazorPage : BaseRazorPage
{
  public WyamBootstrapHelper Bs
  {
    get { return Html.Bootstrap(); }
  }
}
// ...
Pipelines.Add(
  // ...
  Razor(typeof(RazorPage))
  // ...
);
</code></pre>
<p>Once I had the non-blog pages working, I moved on the blog posts. In the previous site each post specified it's metadata (like title, published date, etc.) by setting additional Razor page properties from the custom base class. In this case, I had a better mechanism for specifying metadata and used <a href="https://wyam.io/modules/yaml">YAML</a> <a href="https://wyam.io/modules/frontmatter">front matter</a> for the metadata. This required me to manually change the declarations at the top of each blog post from something like this:</p>
<pre><code>&#64;{
    Title = &quot;Announcing LINQPad.CodeAnalysis&quot;;
    Lead = &quot;.NET Compiler Platform helpers and utilities for LINQPad.&quot;;
    Published = new DateTime(2015, 3, 18);
    Tags = new[] { &quot;LINQPad&quot;, &quot;open source&quot;, &quot;Roslyn&quot;, &quot;.NET Compiler Platform&quot; };
}
</code></pre>
<p>To something like this:</p>
<pre><code>Title: Announcing LINQPad.CodeAnalysis
Lead: .NET Compiler Platform helpers and utilities for LINQPad.
Published: 3/18/2015
Tags:
  - LINQPad
  - open source
  - Roslyn
  - .NET Compiler Platform
---
</code></pre>
<p>It's a nice side benefit that the YAML is easier to read as well. This process took about an hour for all my posts.</p>
<p>The last step was to convert over the more dynamic pages in the site, specifically the <a href="/posts">post archives</a> and <a href="/tags">list of tags</a> and cooresponding tag archives. For the post archive, I wrote a LINQ statement that used the Wyam metadata to fetch all the posts in the site:</p>
<pre><code>&#64;{
  foreach(IGrouping&lt;int, IDocument&gt; year in Documents
    .Where(x =&gt; x.ContainsKey(&quot;Published&quot;))
    .OrderByDescending(x =&gt; x.Get&lt;DateTime&gt;(&quot;Published&quot;))
    .GroupBy(x =&gt; x.Get&lt;DateTime&gt;(&quot;Published&quot;).Year)
    .OrderByDescending(x =&gt; x.Key))
  {
    &lt;h3&gt;&#64;year.Key&lt;/h3&gt;
    // ...
  }
}
</code></pre>
<p>Then for the tags, I did something similar (this uses the special <code>ToLookup</code> extension for handling metadata lookup in Wyam):</p>
<pre><code>&#64;{    
  var DocumentsByTag = Documents
    .ContainsKey(&quot;Published&quot;)
    .ToLookup&lt;string&gt;(&quot;Tags&quot;);
}
// ...
&#64;{
  foreach (var tagDocuments in DocumentsByTag.OrderBy(x =&gt; x.Key))
  {
    // ...
  }
}
</code></pre>
<p>Finally, to generate the individual archive page for each tag, I added a special pipeline that outputs a page per tag:</p>
<pre><code>Pipelines.Add(&quot;Tags&quot;,
  ReadFiles(&#64;&quot;tags\index.cshtml&quot;),
  FrontMatter(),
  Execute((doc, ctx) =&gt; ctx.Documents
    .Where(x =&gt; x.ContainsKey(&quot;Published&quot;) &amp;&amp; x.ContainsKey(&quot;Tags&quot;))
    .SelectMany(x =&gt; x.Get&lt;string[]&gt;(&quot;Tags&quot;))
    .Distinct()
    .Select(x =&gt; doc.Clone(new Dictionary&lt;string, object&gt;()
    { 
      { &quot;Title&quot;, x },
      { &quot;Tag&quot;, x }
    }))),
  Razor(typeof(RazorPage)),
  WriteFiles(x =&gt; HtmlHelperExtensions.GetTagLink(x.String(&quot;Tag&quot;)) + &quot;.html&quot;)
);
</code></pre>
<p>In total, it probably took me about 6 hours to convert over the entire site. While it wasn't turn-key, that's not really the point anyway. I could have built the site from scratch on a site generator that prescribed a specific file convention, metadata, etc. but instead I was able to relativly easily adapt an existing, fairly complex site without too much trouble. That's the reason I built Wyam, to give developers a powerful tool to build exactly the content they want, the way they want to build it. Now it's <a href="https://wyam.io/knowledgebase/continuous-integration">building automatically from AppVeyor on every commit</a>, I can use <a href="https://wyam.io/modules/markdown">Markdown</a>, and it gets served lightning-fast for free from <a href="https://pages.github.com/">GitHub Pages</a>. If you're interested in doing something similar, <a href="https://github.com/daveaglick/daveaglick">check out the source code for this site</a> as an example. And please don't hesitate to ask here or on Twitter for help!</p>
