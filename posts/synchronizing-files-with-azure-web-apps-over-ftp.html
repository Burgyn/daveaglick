<p>I've recently been experimenting with Azure for static site hosting. While there are lots of great static site hosts (<a href="/posts/moving-to-netlify">my personal favorite</a> still remains <a href="https://www.netlify.com">Netlify</a>), <a href="https://azure.microsoft.com/en-us/services/app-service/web/">Azure Web Apps</a> offer some attractive features to enterprises or organizations already invested in Azure. One would think that easily deploying a static site to Azure would be relatively straightforward. Unfortunately, I found that this wasn't the case at all. While Azure Web Apps have some advanced <a href="https://docs.microsoft.com/en-us/azure/app-service-web/web-sites-deploy">deployment options</a> like <a href="https://github.com/projectkudu/kudu/wiki/Deployment">Kudu</a> for git deployments and <a href="http://www.iis.net/learn/publish/using-web-deploy/introduction-to-web-deploy">Web Deploy</a> for deployments from Visual Studio, both require some setup and configuration, are designed with &quot;application&quot; scenarios in mind, and aren't as straightforward as a simple <a href="https://en.wikipedia.org/wiki/File_Transfer_Protocol">FTP upload</a>. Unfortunately, even FTP uploads to Azure Web Apps have some issues that I'll discuss below. To address this scenario, I ended up writing a little bit of code to automatically synchronize a local static site with an Azure Web App FTP server that ignores unchanged files.</p>
<h1 id="challenges-of-ftp-for-static-sites">Challenges of FTP For Static Sites</h1>
<p>Using FTP may seem like an attractive option for uploading a static site. It's easy to understand, lots of client libraries and software exists, and you don't need to do anything particularly special from a devops perspective. For small sites this works great. You just point your FTP client to Azure, delete the old stuff, and upload the new stuff. However, this process starts to break for much larger sites with lots of pages or large resources like images or PDF files. In those cases it can become very time consuming to re-upload everything in the site over and over again.</p>
<p>The normal way to deal with this problem is to attempt to compare files on your local system with those on the FTP server. There are four possible states:</p>
<ul>
<li>A file exists locally that doesn't exist remotely.</li>
<li>A file exists remotely that doesn't exist locally.</li>
<li>A file exists in both places and is different.</li>
<li>A file exists in both places and is the same.</li>
</ul>
<p>Those last two conditions are the tricky ones. It's easy enough to tell if a file exists locally or on the remote server, but what does &quot;different&quot; and &quot;the same&quot; mean and how can we tell? The trick is figuring out how to determine if a file is &quot;the same&quot; without actually having to download that file from the remote server. There are a number of different ways to deal with this when using FTP but they all have either problems when considering static sites or when dealing with the Azure Web Apps FTP server.</p>
<ul>
<li>One common approach is to compare creation timestamps. The idea is that if a file was created at the same time and is the same size then it's probably the same file. This works great for dynamics sites where the files you're uploading constitute source code and don't regularly change. However, in a static site you're probably re-generating the files on every build. That creates new local files each time with new time stamps. Thus the time stamps are essentially useless for static sites.</li>
<li>We could try asking the FTP server for hash codes. Some FTP servers support this either through a <a href="https://tools.ietf.org/html/draft-ietf-ftpext2-hash-03">proposed IETF standard for the HASH command</a> (which expired without ever being officially adopted) or via non-standard hashing commands like XMD5. Unfortunately the Azure Web Apps FTP server doesn't support HASH or any of the other non-standard hashing commands.</li>
<li>Some FTP servers also support CRC checks using he XCRC command which would probably be good enough for our purposes. That's also unsupported on the Azure Web Apps FTP server.</li>
</ul>
<p>This leaves us with a bit of a conundrum. How can we determine if a file on the remote server is different than the one on our local system without downloading it first? The answer is to hash the file on your local system and then store the result of that hash operation on the remote server. Then when we need to compare files we just have to download this set of pre-computed hashes that match the files on the remote server and use them instead.</p>
<h1 id="implementation">Implementation</h1>
<p>Here is an implementation of this synchronization process. It uses the <a href="https://github.com/hgupta9/FluentFTP">FluentFTP</a> library, though any FTP library should work with the overall approach. This creates a <code>hashes.xml</code> file on the remote server to store the remote file hashes.</p>
<pre><code>string host = &quot;something.ftp.azurewebsites.windows.net&quot;;
string username = &quot;azure-ftp-username&quot;;
string password = &quot;azure-ftp-password&quot;;
string localPath = &#64;&quot;C:\StaticSite\output&quot;;
string remotePath = &quot;/site/wwwroot&quot;;

using (FtpClient client = new FtpClient())
{            
    // Note sure why we need to change these, but get timeout exceptions from FluentFTP if we don't
    client.SocketPollInterval = 1000;
    client.ConnectTimeout = 2000;
    client.ReadTimeout = 2000;
    client.DataConnectionConnectTimeout = 2000;
    client.DataConnectionReadTimeout = 2000;

    // Get the connection
    client.Host = host;
    client.Credentials = new System.Net.NetworkCredential(username, password);
    client.EncryptionMode = FtpEncryptionMode.Implicit;
    client.SslProtocols = System.Security.Authentication.SslProtocols.Default;
    client.Connect();

    // Get the remote hashes
    Dictionary&lt;string, string&gt; remoteHashes = null;
    string remoteHashesFile = $&quot;{remotePath}/hashes.xml&quot;;
    if (client.FileExists(remoteHashesFile))
    {
        using (MemoryStream stream = new MemoryStream())
        {
            if (client.DownloadFile(stream, remoteHashesFile))
            {
                XElement items = XElement.Parse(client.Encoding.GetString(stream.GetBuffer()).Replace((char)0x00, ' '));
                remoteHashes = items.Descendants(&quot;file&quot;)
                    .ToDictionary(x =&gt; x.Attribute(&quot;path&quot;).Value, x =&gt; x.Attribute(&quot;hash&quot;).Value);
            }
        }
    }
    
    // Get all local files
    Dictionary&lt;string, FileMapping&gt; mappings =
        System.IO.Directory.GetFiles(localPath, &quot;*&quot;, SearchOption.AllDirectories)
        .Select(x =&gt; new
        {
            LocalFile = x,
            RemoteFile = $&quot;{remotePath}/{x.Substring(localPath.Length + 1).Replace(&quot;\\&quot;, &quot;/&quot;)}&quot;
        })
        .ToDictionary(x =&gt; x.RemoteFile, x =&gt;
        {
            string remoteHash = null;
            return new FileMapping
            {
                LocalFile = x.LocalFile,
                LocalHash = GetHash(x.LocalFile),
                RemoteHash = (remoteHashes?.TryGetValue(x.RemoteFile, out remoteHash) ?? false) ? remoteHash : null
            };
        });    
    
    // Delete everything on the remote not existing locally
    Stack&lt;string&gt; remoteDirs = new Stack&lt;string&gt;();
    remoteDirs.Push(remotePath);
    while (remoteDirs.Count &gt; 0)
    {            
        // Iterate the child items
        foreach (FtpListItem remoteItem in client.GetListing(remoteDirs.Pop()))
        {                
            if (remoteItem.Type == FtpFileSystemObjectType.Directory)
            {
                // Push this directory on the stack to scan next
                remoteDirs.Push(remoteItem.FullName);
            }
            else if (remoteItem.Type == FtpFileSystemObjectType.File &amp;&amp; !mappings.ContainsKey(remoteItem.FullName))
            {
                // Destination file doesn't exist locally
                client.DeleteFile(remoteItem.FullName);
            }
        }
    }
    
    // Now we're left with files locally that either don't exist on remote, have changed, or are the same
    foreach (KeyValuePair&lt;string, FileMapping&gt; mapping in mappings)
    {
        if (mapping.Value.RemoteHash == null || mapping.Value.LocalHash != mapping.Value.RemoteHash)
        {
            // Have to delete first if it exists, see https://github.com/hgupta9/FluentFTP/issues/46
            if (client.FileExists(mapping.Key))
            {
                client.DeleteFile(mapping.Key);
            }
            
            // Either doesn't exist on the remote or is different
            client.UploadFile(mapping.Value.LocalFile, mapping.Key, true);
        }
        else
        {
            // Same, just output a message if you want to
        }
    }

    // Create and upload the hash file
    XElement localHashes = new XElement(&quot;files&quot;, mappings.Select(x =&gt; 
        new XElement(&quot;file&quot;,
            new XAttribute(&quot;path&quot;, x.Key),
            new XAttribute(&quot;hash&quot;, x.Value.LocalHash))));
    client.UploadFile(client.Encoding.GetBytes(localHashes.ToString()), remoteHashesFile, true);
}
</code></pre>
<h1 id="things-to-keep-in-mind">Things To Keep In Mind</h1>
<p>While this approach has proven to be stable and robust for me, there are a couple of caveats.</p>
<ul>
<li>I talk about FTP in this post because that's the underlying protocol. In reality you should almost never use FTP alone. Instead you should use FTPS to communication with the Azure Web App FTP server over SSL to ensure the connection is secure. The code above reflects this, but it's worth reiterating.</li>
<li>The static generation needs to be deterministic. The hashing concept only works if the static output files are the same. If small bits of content change in the output files from one generation to the next, you'll end up with different hashes and those files will be uploaded again.</li>
<li>Try to make sure the entire upload finishes since the hash file is deleted as the first step and isn't uploaded again until completion. This is on purpose as a fail safe. If the process fails the site will be left without a hash file and everything will get uploaded fresh (replacing files that may not have changed).</li>
<li>Make sure to always update the hash file. If remote files change and the hash file isn't updated, the deployment process may not come to the correct conclusion about the file's sameness and may either replace it unnecessarily, or worse, not replace it when it should be replaced.</li>
<li>I didn't include any output statements in the code above, but in practice I usually write out to the console or a log with the progress and what is happening with each file.</li>
</ul>
